###  泛型（Generics）

------

[TOC]

##### 01：泛型的擦除机制

- 定义：参数化类型，给类加参数，达到动态的确定类型的目的，只在编译阶段有效，泛型信息不会进入到运行阶段。
- 在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加**类型检查和类型转换**的方法。
- 通配符（？）：通配符代表任意类型

##### 02：泛型特点

1. 泛型的类型参数只能是类类型，因为传递的是对象
2. 泛型的类型参数可以有多个
3. 不能对确切的泛型类型，使用 instanceof 判断
4. 使用通配符创建泛型数组是可以的
   - ```java
     List<?>[] ls = new ArrayList<?>[10];
     ```

##### 03：通配符-PECS 原则（Producer Extends Consumer Super）

- ？extends E ：向上限定，？代表E 本身或者其子类，也可以称之为：泛型固定上边界
  - 做添加操作的时候，**你只知道你添加数据的上限，无法确定你要添加数据的下限，因此无法添加数据**，只能读取；
- ？super E ：向下限定， ？代表 E 本身或者其父类 (泛型固定下边界)   在做添加的时候是不会有问题的
  - 泛型的下边界，已经限制。再向集合中添加数据,只能是其本身或者他的子类
- PECS 原则：是一种泛型使用规范，用于指导在何时使用 `extends` 和 `super` 限定泛型类型参数。
  - 如果要从集合中**读取数据**，使用 `extends` 通配符限定泛型类型上界；
  - 如果要向集合中**写入数据**，使用 `super` 通配符限定泛型类型下界。


```java
List<? extends Number> numList = new ArrayList<>();
// 代表这个类型是 Number的子类型 但是不确定是什么 不能add 但是可以get 出来是个object
// numList.add(1); 会出问题
Number num = (Integer) flist.get(0);

List<? super Number> numList = new ArrayList<>();
numList.add(1);
```

##### 04：泛型（类，接口）

###### 泛型类：在实例化类的时候指明泛型的具体类型

```java
public static class Person<T> {  
    private T ob;
    public Person(T ob) {  
        this.ob = ob; 
    }
} 	 
// T的实际类型是整型
Person<Integer> person = new Person<>(100);
```

###### 泛型接口

```java
public interface Animal<T> {
		
}
```

- 当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中

```java
public class A<T> implements Animal<T> {

}
```

- 实现泛型接口的类，传入泛型实参时，则所有使用泛型的地方都要替换成传入的实参类型

```java
public class A implements Animal<String> {

}
```

##### 05：泛型方法

```java
// 只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法
public <T> void method(T e) {
  	
}
```

##### 06：泛型原理

###### 类型声明

- ```java
  /**
   * 定义一个泛型类，其中
   *
   * Type Parameter 是T extends Number
   * Type Variable 是T
   * Type Argument 是Foo<Integer>里的Integer
   */
  class Foo<T extends Number> {}
  ```

###### 类型擦除的缺陷

- 无法通过反射API，在运行期获得Type Variable所代表的类型。

###### 获取泛型的运行时类型

- ```java
  
  public static <T> Type getGenericRuntimeType(Wrapper<T> wrapper) {
      Type type = wrapper.getClass().getGenericSuperclass();
      if (type == null) {
          return null;
      }
  
      if (type instanceof ParameterizedType) {
          Type[] types = ((ParameterizedType)type).getActualTypeArguments();
          return types[0];
      }
      return null;
  }
  
  // null
  Type type1 = getGenericRuntimeType(new Wrapper<List<String>>());
  // java.util.List<java.lang.String>
  Type type2 = getGenericRuntimeType(new Wrapper<List<String>>() {});
  ```

###### 原理

- Java 的编译器**将泛型信息写入到 Class 文件中的 Signature 属性中**。然后通过JRE的反射接口解析Signature中的字符串，最终分析出被隐藏的运行时类型信息。

- ```java
  public Type getGenericSuperclass() {
      ClassRepository info = getGenericInfo();
      if (info == null) {
          return getSuperclass();
      }
      // Historical irregularity:
      // Generic signature marks interfaces with superclass = Object
      // but this API returns null for interfaces
      if (isInterface()) {
          return null;
      }
  
      return info.getSuperclass();
  }
  
  private ClassRepository getGenericInfo() {
      ClassRepository genericInfo = this.genericInfo;
      if (genericInfo == null) {
          // native 方法，编译器实现，作泛型签名处理
          String signature = getGenericSignature0();
          if (signature == null) {
              genericInfo = ClassRepository.NONE;
          } else {
              genericInfo = ClassRepository.make(signature, getFactory());
          }
          this.genericInfo = genericInfo;
      }
      return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
  }
  
  private native String getGenericSignature0();
  ```

