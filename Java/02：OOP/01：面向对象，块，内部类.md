### 面向对象

------

[TOC]

可以用对象来表示和处理现实生活中那些有着潜在关系和复杂结构的实体，映射成数据库中的行列；

##### 01：面向对象的设计三大特点：封装，继承，多态

五大原则是"单一职责原则"、"开放封闭原则"、"里氏替换原则"、"依赖倒置原则"、"接口分离原则"

- **单一职责原则**：是指一个类的功能要单一，不能包罗万象
- **开闭原则**：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的（高内聚，低耦合）
- **接口分离原则**：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
- **里式替换原则**：子类应当可以替换父类并出现在父类能够出现的任何地方
- **依赖倒置原则** ：具体依赖抽象，上层依赖下层

##### 02：对象和类

对象是现实世界中真实存在的实体，有两部分组成：静态部分 + 动态部分

- 对象：属性(封装方法执行时所用的数据) + 方法
- 类：把具有共同属性和共同方法的多个对象称为一个类

###### 对象和类的关系

- 类是封装对象的属性和方法的载体，类是对象的抽象，而对象是类的实例化
- 注意：类是Java程序的基本编程单位

##### 03：对象的创建语法 

- 自定义类型  引用变量名 = new  构造方法（）;  


##### 04：类的创建语法

- 访问权限修饰符    修饰符     class  类名    {   //类体   }


###### 类体：

- 属性（成员变量，全局变量)： 用来封装该类中方法所需要的数据
- 声明语法：【访问权限修饰符】【修饰符】数据类型 变量名；
- 全局变量的默认值：整型：0，浮点型（double）：0.0，char：'' ，boolean：false
- 引用数据类型默认值是：null

##### 05：方法：具有特定功能的指令和数据的集合

- **声明语法：**访问权限修饰符  修饰符   返回值类型  方法名（形参列表）{ 方法体}
- **局部变量**：为该方法特定的提供服务的变量
- 注意：**局部变量没有默认值，使用之前必须进行初始化（赋初值）**
- 构造方法：访问权限修饰符   方法名（形参列表）{ 方法体    }
- 注意：构造方法属于类，没有修饰符，返回值类型，方法名和类名相同，只伴随 new 关键字出现，自动调用
- 如果类中没有构造方法时，JVM 会默认的提供一个无参的构造方法，当你自己写出构造方法时就不再默认提供，就需要自己写一个无参的构造方法，否则使用继承时会报错
- 构造器的作用：
  1. 创建对象
  2. 对对象的属性进行初始化

###### 方法分类：

- 实例方法：用实例中的数据产生不同结果的方法
- 构造方法：属于类，初始化对象的
- 静态方法：属于类，每个对象调用产生同样的结果
- native方法：不是用Java编写的而是用c或者c++编写的

##### 06：类的高级特性：块、内部类

###### 块：在大括号中的代码

- 实例块： {   //实例块代码  }
  - 实例块是在创建对象之前，默认去访问的代码块，每创建一个对象都会去默认执行，多个实例块按照声明顺序执行
- 静态块：  static {   //静态块代码 }
- 同步块：synchronized(class对象){ }
- fianlly 块： finally{ }

###### 内部类 (Inner Class) 和 外围类，静态内部类 (Static Nested Class)  

- 静态内部类：
  - static，它不依赖于外部类实例被实例，new一个静态内部类不需要外部类成员；
  - 静态内部类对象的创建：外围类名.内部类名  内部类变量名  = new 外围类类名.内部类的构造方法

```java
public class OutClass {
    public static class InnerStaticClass {

    }
}
// 创建内部类对象
OutClass.InnerStaticClass innerclassname = new OutClass.InnerStaticClass();
```

- 内部类：需要在外部类实例化后才能实例化，分为普通内部类，局部内部类，匿名内部类

###### 普通内部类：

- 存在于一个类中的类，它里面可以有类体的所有元素，但是都不能被static修饰，能访问外围类中的所有元素
- 普通内部类对象创建格式：
  - 外围类名.内部类名  内部类变量名 = new 外围类的构造方法.new 内部类的构造方法

###### 局部内部类：

- 作用在一个方法中的内部类，只能访问其所在方法中 final 所修饰的变量
- 通过创建外围类的对象，调用外围类的方法，来执行局部内部类的的方法

###### 匿名内部类：

就是没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法

- 使用时：**如果想创建一个类的对象，并且该类只用一次**
  - 类在定义后马上用到
  - 匿名内部类不能有构造方法
  - 内部类不能定义任何静态的成员、方法和类
  - 只能创建匿名内部类的一个实例
  - 一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类

- 匿名内部类的两种实现方式：
  - 继承一个类，重写其方法
  - 实现一个接口，实现其方法

```java
// Object的子类
new Object() {
    @Override
    void show() {
        System.out.println("show run");                
    }
}.show();

// 创建一个子类对象，没有名字，创建子类的对象，引用叫obj, 大括号为子类类体
Object obj = new Object() {
    @Override
    void show() {
        System.out.println("show run");
    }
};
obj.show();
```

##### 07：创建对象的方式

1. new
2. 反射
3. 反序列化
4. 克隆

#####  08：访问对象两种方式

​	reference 类型数据来作为对象内存数据的引用，但JVM规范没有定义这个引用应该通过何种方式定位、访问堆上的对象，也不强制规定对象的内部结构应当如何表示；

###### 1：使用句柄池（用于表示对某个对象或资源的引用或标识符，通常是系统分配的整数值）

- Java堆划分一块内存作为句柄池，reference 中存储就是对象的句柄地址（含有两个地址）
  - 在堆中分配的对象实例数据的地址；
  - 方法区的对象类型数据地址；

###### 2：使用直接指针

- reference 中存储就是在**堆中分配的对象实例数据的地址**；而对象实例数据中需要有这个对象类型数据的相关信息（方法区）

