### 序列化、反序列化

------

[TOC]

##### 01：概述

- 对象的序列化： 将对象转换为字节序列的过程
- 对象的反序列化：将字节序列恢复为对象的过程

###### 序列化作用

​	在传递和保存对象的时候，保证对象的完整性和可传递性，字节序列保存了Java对象的状态以及相关的描述信息

###### 序列化机制的核心

​	对象状态的保存与恢复

###### 序列化用途

- 实现了数据的持久化：即把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，例如Session ；
- 实现了远程通信：即在网络上传送对象的字节序列，例：两个进程远程通信时，传递对象信息；

##### 02：实现序列化

必须实现 Serializable 接口或 Externalizable 接口，Serializable 没有方法，只是为了标注该对象是可被序列化的

```java
package java.io;
public interface Serializable {

}
// 实现了 Serializable 接口的类
// 在反序列化中，不会调用任何构造器，整个对象都是通过从 InputStream 中恢复数据的
public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}
// 反序列化时，对象恢复后，其内部的某些子对象需要重新创建，从而不必将该子对象序列化，对序列化过程进行控制
// 可以用 transient 替代
```

##### 03：transient

​	用来修饰属性，当被修饰后，对象进行序列化时，**该属性值（临时的）被忽略**，从而达到瘦身的目的；

##### 04：序列化的ID

- Java的序列化机制：通过判断**类的serialVersionUID来验证版本一致性的**
- 生成方式：通过将 Java **类的结构和属性信息进行哈希**计算得出的一个唯一标识符；
- 在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与相应实体类的serialVersionUID （Java 运行时系统自动生成）进行比较，如果是一致的，反序列化成功，若不一致：反序列化直接抛出序列化版本不一致的异常即：InvalidCastException；

###### 隐式声明

- 当实体类中没有显示的定义一个名为“serialVersionUID”、类型为long的变量时，Java序列化机制在运行时，会根据编译时的class文件（类的结构和属性信息），自动生成一个 serialVersionUID 作为序列化版本比较。

- ```java
  private static final long serialVersionUID = 1L;
  ```

###### 显式声明

- 在某些场合，希望类的不同版本对序列化兼容(向后兼容)，因此需要确保类的不同版本具有相同的serialVersionUID

##### 05：序列化与反序列化的两种方式

###### 1：若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化

- ObjectOutputStream 采用默认的序列化方式，对User对象的非transient的实例变量进行序列化；
- ObjcetInputStream 采用默认的反序列化方式，对User对象的非transient的实例变量进行反序列化；

###### 2：若User类实现了Externalnalizable接口，且User类实现其方法

- ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化；
- ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化；

##### 06：特点

1. 序列化时，只对对象的状态进行保存，而不管对象的方法
2. 声明为  transient 类型的成员数据不能被序列化，因为transient代表对象的临时数据
3. 当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口
4. 当一个对象的成员变量为引用对象，序列化该对象时也把引用对象进行序列化
6. Java有很多基础类已经实现了serializable接口，比如String,Collection等

##### 07：实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

```java
public static <T extends Serializable> T clone(T obj) throws Exception {
	 ByteArrayOutputStream bout = new ByteArrayOutputStream(); 
	 ObjectOutputStream oos = new ObjectOutputStream(bout); 
	 oos.writeObject(obj); 
	 ByteArrayInput Stream bin = new ByteArrayInputStream(bout.toByteArray()); 
	 ObjectInputStream ois = new ObjectInputStream(bin); 
	 return (T) ois.readObject(); 
}
```