### 网络 IO

------

[TOC]

##### 01：IO

- **I/O：**在计算机领域常说的IO包括**磁盘 IO（访问磁盘数据） 和网络 IO（socket 读取）**，而我们所说的IO复用主要是指网络 IO。
- 在Linux中一切皆文件，因此**网络IO**也经常用**文件描述符 FD** 来表示。

###### IO多路复用

- **多路：指的是多个socket连接，复用：指的是复用一个线程。**
  - 采用多路 I/O 复用技术**可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）**；
  - 多路复用主要有三种技术：select，poll，epoll。

##### 02：网络IO 的演进

1. 阻塞 IO(BIO)
2. 非阻塞 IO(NIO)
3. IO 多路复用第一版(select/poll)
4. IO 多路复用第二版(epoll)
5. 异步 IO(AIO)

##### 03：**网络的两个阶段**

- 在网络中，我们通常可以将其广义上划分为以下两个阶段：
  - 第一阶段：硬件接口到内核态（传输层）；
  - 第二阶段：内核态到用户态；

##### 04：阻塞IO（Blocking)、非阻塞 IO (NonBlocking)

- 把从**硬件接口到内核态这一阶段，是否发生阻塞等待**，可以将网络分为**阻塞 IO**和**非阻塞 IO**；
- 如果用户发起了读写请求，但**内核态数据还未准备就绪，该阶段不会阻塞用户操作**，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。

##### 05：同步IO (Synchronization IO)、异步IO (Asynchronous IO) 

- 同步和异步都是**基于应用程序让操作系统去处理 IO 事件的方式**（应用程序和IO线程之间）；
- **同步：**用户进程触发IO 操作并**等待或者轮询**的去查看IO 操作是否就绪，这时**应用程序不能处理其他**的事情；
- **异步：**用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知，这时**应用程序可以处理其他**的事情；

##### 06：BIO(Blocking IO)： 阻塞 IO

- 当用户发生了系统调用后，如果数据未从网卡到达内核态，**内核态数据未准备好，此时会一直阻塞**。直到数据就绪，然后从**内核态拷贝到用户态再返回**；

###### 阻塞IO的缺点

- 在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是**阻塞 IO+多线层**，每个连接一个单独的线程进行处理。
- 导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理；

##### 07：NIO（NonBlocking IO）：非阻塞 IO

- 在第一阶段(网卡-内核态)数据未准备好时，**不等待直接返回**。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据是否ok。

###### 非阻塞性 IO 优点

- 非阻塞 IO 解决了阻塞 IO**每个连接一个线程处理的问题**，所以其最大的优点就是 **一个线程可以处理多个连接**；

###### 非阻塞性 IO 缺点

- 需要用户多次发起系统调用。**频繁的系统调用**是比较消耗系统资源的。

##### 08：第一代 IO 多路复用（select/poll）

![](/Users/likang/Code/Git/Java/Java/07：IO/photots/io-select.png)

###### select API（轮询）

```c++
// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

- 调用后 select 函数会阻塞，直到有**描述符就绪**（有数据 可读、可写、或者有 except），**或者超时**（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以**通过遍历 fdset**，来找到就绪的描述符。
- select 的一 个缺点在于**单个进程能够监视的文件描述符的数量存在最大限制**，在 Linux 上一般为 1024；

###### poll API

```c++
int poll (struct pollfd *fds, unsigned int nfds, int timeout);

struct pollfd {
    int fd; /* file descriptor */
    short events; /* requested events to watch */
    short revents; /* returned events witnessed */
};
```

- pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并**没有最大数量限制**（但是数量过大后性能也是会下降）。 和 select 函数一样，poll 返回后，需要**轮询 pollfd 来获取就绪的描述符**。

###### 第一代 IO 多路复用的优点

- 主要在于复用，通过 select()或者 poll()**将多个 socket fds 批量通过系统调用传递给内核**，由内核进行循环遍历判断哪些 fd 上数据就绪了，然后将**就绪的 readyfds 返回给用户**。再由用户进行挨个**遍历就绪好的 fd**，读取或者写入数据。
- 通过 IO 多路复用+非阻塞 IO，一方面降低了**系统调用次数**，另一方面可以**用极少的线程来处理多个网络连接**。

###### 第一代 IO 多路复用的缺点

- 用户每次将**海量的 socket fds 集合从用户态传递到内核态**，让内核态去检测哪些网络连接数据是否就绪，**再从内核态拷贝到用户态**。这个地方开销也挺大。

##### 09：第二代 IO 多路复用（epoll）

###### epoll

```c++
// 创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表
// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
int epoll_create(int size)；

// 往红黑树中增加、删除、更新管理的socket fd
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；

// 这个api是用来在第一阶段阻塞，等待就绪的fd
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

- epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）
- **LT(level triggered)：水平模式，是缺省的工作方式，并且同时支持 block 和 no-block socket，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，**内核还是会继续通知你的（通知多次）**。
- **ET（edge trigger）：边沿模式，高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，**并且不会再为那个文件描述符发送更多的就绪通知（通知一次）**，直到你做了某些操作导致那个文件描述符不再为就绪状态了。

###### 第二代 IO 多路复用的优点

- 一开始就在**内核态分配了一段空间，来存放管理的 fd**，所以在每次连接建立后，交给 epoll 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。

##### 10：异步 IO

![](/Users/likang/Code/Git/Java/Java/07：IO/photots/AIO.png)

- **内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成；**
- 目前只有 windows 系统的 IOCP 是属于异步 IO；

##### 11：网络 IO 模型

![](/Users/likang/Code/Git/Java/Java/07：IO/photots/Reactor.png)

​	一个 Acceptor负责接受IO请求，把接收到Socket Channel注册到（按某种算法从 Reactor 池中取出的一个）Reactor上，注册的事件为读，写等，之后这个Socket Channel 的所有IO事件都和Acceptor没关系，都由被注册到的那个Reactor来负责。

- Reactor：由**一个专门的线程来处理所有的IO事件，并负责分发线程去处理**。
- 事件驱动机制：事件到的时候触发，而不是同步的去监视事件，保证每次上下文切换都是有意义的，减少无谓的线程切换。











