### Socket

------

[TOC]

##### 01：sock【操作系统内核里】

- 一种基于内核网络传输的数据结构；
  - 包含以下数据
    - IP
    - 端口
    - 发送缓冲区->消息
    - 接受缓冲区
    - 等待队列-> 进程
- `sock`：是**最基础**的结构，维护一些任何协议都有可能会用到的收发数据缓冲区。
- `inet_sock`：特指用了**网络传输**功能的`sock`，在`sock`的基础上还加入了`TTL`，**端口，IP地址**这些跟网络传输相关的字段信息。说到这里大家就懵了，难道还有不是用网络传输的？有，比如`Unix domain socket`，用于本机进程之间的通信，直接读写文件，不需要经过网络协议栈。
- `inet_connection_sock`：是指**面向连接**的`sock`，在`inet_sock`的基础上加入面向连接的协议里相关字段，比如`accept队列`，数据包分片大小，握手失败重试次数等。虽然我们现在提到面向连接的协议就是指TCP，但设计上linux需要支持扩展**其他**面向连接的**新协议**。
- `tcp_sock`： 就是**tcp协议**专用的`sock`结构了，在`inet_connection_sock`基础上还加入了tcp特有的**滑动窗口**、**拥塞避免**等功能。同样udp协议也会有一个专用的数据结构，叫`udp_sock`。
- <img src="/Users/likang/Code/Git/Programming-Language/Java/07：IO/photots/socket.png" alt="socket" style="zoom:40%;" />

##### 02：Socket

- **将内核的sock封装成文件**。创建`sock`的同时也创建一个**文件**，**文件有个句柄 fd**，说白了就是个**文件系统**里的**身份证号码**，通过它可以**唯一确定**是哪个`sock`。

- 将句柄暴露给用户，用户就可以像操作**文件句柄**那样去操作这个**sock句柄**。在用户空间里操作这个句柄，**文件系统**就会将操作**指向**内核`sock`结构。

  - ```shell
    sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    ```

###### 支持的方法

- `send()`，`recv()`，`bind()`, `listen()`，`connect()`

###### 数据传输

- 当应用执行`send()`方法**发送数据**时，同样也会通过`sock_fd`句柄找到对应的文件，根据文件指向的`sock`结构，找到这个`sock`结构里带的**发送缓冲区**，将数据会放到发送缓冲区，然后结束流程，**内核看心情决定什么时候将这份数据发送出去**。
- **接收数据**流程也类似，当数据送到linux内核后，数据不是立马给到应用程序的，而是先放在接收缓冲区中，数据静静躺着，卑微的等待**应用程序**什么时候执行`recv()`方法来拿。

###### 接收数据

- 当你的应用进程执行`recv()`方法尝试获取（阻塞场景下）接收缓冲区的数据时。
  - 如果有数据，那正好，取走就好了。
  - 但如果没数据，就会将自己的**进程**信息注册到这个sock用的**等待队列**里，然后进程**休眠**。如果这时候有数据从远端发过来了，数据进入到接收缓冲区时，内核就会取出sock的等待队列里的进程，**唤醒**其中一个进程来取数据。
  - <img src="/Users/likang/Code/Git/Programming-Language/Java/07：IO/photots/receive_queue.png" alt="receive_queue" style="zoom:40%;" />

##### 03：Socket 总结

- 在操作系统内核空间里，**实现网络传输功能的结构是sock**，基于不同的协议和应用场景，会被泛化为各种类型的xx_sock，它们结合硬件，共同实现了网络传输功能。为了将这部分功能暴露给用户空间的应用程序使用，于是引入了socket层，同时将sock嵌入到文件系统的框架里，sock就变成了一个特殊的文件，**用户就可以在用户空间使用文件句柄**，也就是socket_fd来操作内核sock的网络传输能力。

##### 04：半连接队列 & 全连接队列

- **半连接队列（SYN队列）**，服务端收到**第一次握手**后，会将`sock`加入到这个队列中，队列内的`sock`都处于`SYN_RECV` 状态。
- **全连接队列（ACCEPT队列）**，在服务端收到**第三次握手**后，会将半连接队列的`sock`取出，放到全连接队列中。队列里的`sock`都处于 `ESTABLISHED`状态。这里面的连接，就**等着服务端执行accept()后被取出了。**
- 建立连接的过程中根本不需要`accept()` 参与， **执行accept()只是为了从全连接队列里取出一条连接**
- 虽然都叫**队列**，但其实**全连接队列（icsk_accept_queue）是个链表**，而**半连接队列（syn_table）是个哈希表**。

###### 全连接队列满了会怎么样？

- 如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。但除了丢弃之外，还有一些附带行为，这会受 `tcp_abort_on_overflow` 参数的影响。
- **`tcp_abort_on_overflow`设置为 0**，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的 SYN+ACK，如果重传超过一定限制次数，还会把对应的**半连接队列里的连接**给删掉。
- **`tcp_abort_on_overflow`设置为 1**，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。
  - 服务端**端口未监听**时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实**无法区分到底是端口未监听，还是全连接队列满了。**

###### 半连接队列要是满了会怎么样？

- **一般是丢弃**，但这个行为可以通过 `tcp_syncookies` 参数去控制。
- **tcp_syncookies 设置为 1**，客户端发来**第一次握手**SYN时，服务端**不会将其放入半连接队列中**，而是直接生成一个`cookies`，这个`cookies`会跟着**第二次握手**，发回客户端。客户端在发**第三次握手**的时候带上这个`cookies`，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。

###### SYN FLOOD 攻击

- **SYN Flood攻击**：攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。

##### 05：没有listen，为什么还能建立连接

- **TCP 自连接**：是由于编程错误或者系统配置不当引起的。当客户端尝试与自己的IP地址和端口号建立连接时，系统会将连接请求发送到自己，但由于没有正在监听该端口的服务端程序，因此连接请求无法被处理，从而导致连接失败。

##### 06：Soceket  缓冲区

- Recv-Q：接受缓冲区，单位Byte；
- Send-Q：发送缓冲区，单位Byte;

