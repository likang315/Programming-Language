### 数据库连接池

------

[TOC]

##### 01：概述

- 将数据库连接（数据库实例）作为对象存储在内存中的连接池，当用户需要访问数据库时，**从连接池中取出一个已建立的空闲连接对象**，使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用，而连接的建立、断开都由连接池自身来管理，类似于线程池的概念。

##### 02：InterFace DataSource

- DataSource 对象表示：物理数据库的数据源，作为 DriverManager工具的替代项，DataSource 对象是获取连接的首选方法；


###### Java 实现数据库连接池操作

1. 实现 Javax.sql.DataSource 接口；
2. 调用 getConnection（）方法得到连接连接池的对象；
   - 通过连接池的参数来控制连接池中的**初始连接数、连接的上下限数以及每个连接的最大使用次数**
3. 调用 Connection 的 close()，将连接放回连接池；

##### 03：数据连接池

###### c3p0 连接池：

1. 将c3p0的jar包加入classpath 
2. 在classpath中加入c3p0.properties
3.  实例化ComboPooledDataSource
4. ComboPooledDataSource.getConnection()；得到连接对象

###### druid （德魯伊）连接池：

1. 加载 mysql-connector-java-5.1.20-bin 数据库驱动

2. 将 druid-1.1.10.jar 加入classpath

3. 在 classpath中加 入druid.properties

4. 实例化DruidDataSource

5. DruidDataSource.getConnection()；得到连接对象

   ```java
   private static DruidDataSource  ds = new DruidDataSource();
   static {
       try {
           // 从配置文件中导入根据值导入
           ResourceBundle res = ResourceBundle.getBundle("druid");
           ds.setUrl(res.getString("url"));
           ds.setDriverClassName(res.getString("driverClassName"));
           ds.setUsername(res.getString("username"));
           ds.setPassword(res.getString("password"));
           ds.setMaxActive(Integer.parseInt(res.getString("maxActive")));
           ds.setInitialSize(Integer.parseInt(res.getString("initialSize")));
	        ds.setMaxWait(Long.parseLong(res.getString("maxWait")));
           ds.setMinIdle(Integer.parseInt(res.getString("minIdle")));
       } catch (Exception e) {
           System.out.println("数据库初始化异常");
       }
   }
   
   public static void main(String[] args) throws Exception {
       ResultSet rs = ds.getConnection().createStatement()
           .executeQuery("select * from person");
       while (rs.next()) {
           System.out.println(rs.getInt(1) + "\t" + rs.getString(2));
       }
   }
   ```

###### HikariCP

- 一个高性能的 JDBC 连接池，被广泛使用，具有快速启动、低延迟和高吞吐量等特点，适用于高并发的应用场景。

- ```java
  HikariConfig config = new HikariConfig();
  config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
  config.setUsername("username");
  config.setPassword("password");
  config.setMaximumPoolSize(10); // 设置最大连接数
  config.setMinimumIdle(5); // 设置最小空闲连接数
  config.setConnectionTimeout(30000); // 设置连接超时时间
  
  HikariDataSource dataSource = new HikariDataSource(config);
  ```

##### 04：数据库连接池的关闭

- 注册为Spring 容器的钩子，在销毁时，自动调用，释放资源。
- kill -2：正常销毁，钩子会被调用；
- kill -9：强制销毁，钩子不会被调用；

##### 	 05：Interface Connection

- void commit()
  - 使所有上一次提交 / 回滚后进行的更改成为持久更改，并释放当前 Connection 对象持有的数据库锁；
- void rollback() 
  - 取消在当前事务中进行的所有更改，并释放此 Connection 对象当前持有的所有数据库锁；
- void setAutoCommit(boolean autoCommit) 
  - 将此连接的自动提交模式设置为给定状态 （mysql为自动提交）；

###### JDBC 事务

- 本身不支持事务，它只是对数据库做了简单的封装，还是用的数据库的事务；

```java
// 关闭mysql事务的自动提交
con.setAutoCommit(fasle); 
try {	
    // 写事务代码
    con.commit();
} catch(Exceptin e) {
    con.rollback();
} finally {
    con.close();
}
```

##### 06：CallableStatement

- 用于调用数据库的存储过程，函数的输出需要注册；
- 存储过程：就 sql语句 写的一个函数（代码片段），有数据库的输入，也有数据的输出

```sql
# 修改数据库分隔符
Delimiter //         
create procedure add_person(pname varchar(23),pwd varchar(45),page int(2),psex varchar(2),OUT counter int)
begin
insert into person(name,pwd,age,sex) values(pname,ppwd,page,psex);
select count(*) into counter from person;
End
//
Delimiter ;
```

##### 07：DbUtils

- 封装操作数据库的 updata，query，传 SQL 语句，参数即可执行；
- 使用 Apache 的 commons 的 dbutils 的工具类包，封装了 ArrayListHandler，BeanListHandler，XXXHandler类ResultSetHandler 接口的实现类，实例化 QuenyRunner 类，即可使用；

- import org.apache.commons.dbutils.QueryRunner;

###### Interface ResultSetHandler

- 把数据库记录封装成对象的处理器，其实现类：

- XXXhandler（）：T handle(ResultSet rs) 重写此方法，将结果集封装成对象

  1. ArrayHandler：适合取1条记录，把结果集中的第一行数据转成对象数组。
  2. ArrayListHandler
  3. BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中
  4. BeanListHandler

  ```java
  import java.sql.ResultSet;
  
  public interface ResultSetHandler<T> {
      // 结果集封装成对象，重写其方法
      public T handle(ResultSet rs);
  }
  ```


###### Class QueryRunner ：发送 SQL 语句的，相当于 PreparedStatement 对象

- QueryRunner() 

- QueryRunner(DataSource ds)

- int[] batch(Connection conn, String sql, Object[][] params) 

  - 批处理执行SQL语句 

- int[] batch(String sql, Object[][] params) 

  - 批处理执行SQL语句

- query(String sql, ResultSetHandler rsh, Object... params)

- query(Connection conn, String sql, ResultSetHandler rsh, Object... params)

- update(Connection conn, String sql, Object... params)

- int update(Connection conn, String sql, Object param)

  ```java
  // 或者直接传入数据源DS
  QueryRunner run = new QueryRunner();
  Connection con = ds.getConnection(); 
  List<Person> list = run.query(con, "select * from person where id>?",
                                new BeanListHandler<Person>(Person.class), 1);
  Person p = run.query(con, "select * from person where id = ？",
                       new BeanHandler<Person>(Person.class), 1);
  Object[] list = run.query(con, "select * from person where id > ?", new ArrayHandler(), 1);
  List<Object[]> list = run.query(con, "select * from person where id>?",
                                  new ArrayListHandler(), 1);
  
  // 重写了DbUtils 的 query
  public T query(String sql, ResultSetHandler<T> hand, Object... params) {
      T t = null;
      Connection con = null;
      try {
          con = ds.getConnection();
          PreparedStatement ps = con.prepareStatement(sql);
          if (null != params && params.length > 0) {
              for (int i = 0; i < params.length; i++) {
                  ps.setObject(i + 1, params[i]);
              }
          }
          ResultSet res = ps.executeQuery();
          // 将结果映射成对象，实现方法具体看是哪个类
          t = hand.handle(res);
      } catch (SQLException e) {
          System.out.println("Error_03:query 失败");
      } finally {
          try {
              con.close();
          } catch (SQLException e) {
              System.out.println("Error_04:query 连接断开失败");
          }
      }
      return t;
  }
  ```
