### Java 11 新特性

------

[TOC]

##### 01：概述

- Java 11 在 2018 年 9 月 25 日正式发布，将提供**长期支持服务**（LTS, Long-Term-Support），还将作为 Java 平台的默认支持版本，并且会提供技术支持直至 2023 年 9 月，对应的补丁和安全警告等支持将持续至 2026 年。

##### 02：基于嵌套的访问控制

- 嵌套访问控制是一种**控制上下文访问的策略**，允许逻辑上属于同一代码实体，但被**编译之后分为多个分散的 class 文件的类**，无需编译器额外的创建可扩展的桥接访问方法，即可访问彼此的私有成员，并且这种改进是在 Java 字节码级别的。

- Java 11 之前通过桥接方式访问，**11以后直接支持嵌套成员内部的私有访问，不再通过自动生成的桥接方法`access$000`** 。

- Java 11 中引入了两个新的属性

  - | 属性        | 版本号 | 位置                | 解释                                                         |
    | ----------- | ------ | ------------------- | ------------------------------------------------------------ |
    | NestHost    | 55.0   | Class文件属性表结构 | 用于支持嵌套类的反射和控制的 API ，内部类**通过此属性得知自己的宿主类** |
    | NestMembers | 55.0   | Class文件属性表结构 | 用于支持嵌套类的反射和控制的 API ，宿主类**通过此属性得知自己的内部类** |

- 验证嵌套成员的新API

  - `getNestHost`：获取宿主；
  - `getNestMembers`：获取宿主上的成员；
  - `isNestmateOf`：用于检查两个类是否属于同一个嵌套组；

##### 03：简化启动单个源代码文件的方法

- 增强 Java 启动器，使 Java 解释器直接执行 Java 源代码。脚本语言领域；

  - Java 11 之前使用 javac 编译成 class 文件，在执行java命令，之后直接执行 java 类名；

  - ```java
    javac HelloWorld.java
    java HelloWorld
    
    // Java 11
    java HelloWorld
    ```

##### 04：用于 Lambda 参数的局部变量语法

- 在Java 11之前，Lambda表达式**只能引用 final 或 有效final 的局部变量**。而Java 11中，Lambda表达式可以**引用局部变量（包括非final变量）**，这些变量在 Lambda 表达式中**被隐式转换为 final 或有效 final**；

- 使用关键字 var 隐式定义 Lambda 表达式的形参；

- ```js
  // x 是变量
  int x = 10; 
  // Lambda表达式中引用 x
  Runnable r = () -> System.out.println("x = " + x);
  // 使用 var
  (var x, var y) -> x.process(y)
  ```

##### 05：支持 TLS 1.3 协议

- Java 11 中包含了**传输层安全性（TLS）1.3** 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能。
- 新版本中包含了 **Java 安全套接字扩展（JSSE）提供 SSL，TLS 和 DTLS 协议的框架和 Java 实现**。目前，JSSE API 和 JDK 实现支持 SSL 3.0，TLS 1.0，TLS 1.1，TLS 1.2，DTLS 1.0 和 DTLS 1.2。

##### 07：低开销的 Heap Profiling （内存分析）

- Java 11 中提供一种**低开销的 Java 堆分配采样方法**，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息
- 引入这个低开销内存分析工具是为了达到如下目的：
  - 足够低的开销，可以**默认且一直开启**
  - 能通过定义好的程序接口访问
  - 能够对所有堆分配区域进行采样
  - 能给出正在和未被使用的 Java 对象信息

##### 08：飞行记录器

- Java 语言中的飞行记录器类似飞机上的黑盒子，是一种**低开销的事件信息收集框架**，主要用于对应用程序和 JVM 进行故障检查、分析。飞行记录器记录的主要数据源于应用程序、JVM 和 OS，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。

- 启动参数

  - ```shell
    -XX:+FlightRecorder
    -XX:StartFlightRecording:filename=myrecording.jfr
    ```

##### 09：Epsilon：低开销垃圾回收器

- Epsilon 垃圾回收器（A No-Op Garbage Collector）的目标是开发**一个控制内存分配，但是不执行任何实际的垃圾回收工作**。一旦java的堆被耗尽，jvm就直接关闭。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。
- Epsilon 垃圾回收器和其他 OpenJDK 的垃圾回收器一样，可以通过**参数 `-XX:+UseEpsilonGC` 开启**。
- Epsilon 线性**分配单个连续内存块**，Epsilon 用到的 barrier 是空的(或者说是无操作的)，引进一种新的 barrier-set 实现可能是该 GC 对 JVM 最大的变化。

###### 使用场景

- **内存压力测试**：简单地接受一个分配的内存分配上限，当内存超限时就失败
- **吞吐改进**：即便对那些**无需内存分配的工作，选择一个 GC 意味着选择了一系列的 GC 屏障**，所有的 OpenJDK GC 都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。

##### 10：ZGC：可伸缩低延迟垃圾收集器

- ZGC 即 Z Garbage Collector，是ZGC 是一种基于 Region（区域）的可伸缩、低延迟的垃圾回收器，主要为了满足如下目标进行设计：
  - **GC 停顿时间不超过 10ms；**
  - **并发执行**：ZGC 的大部分垃圾回收工作都是在应用程序运行的同时进行的；
  - **应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）；**
  - 可以处理超过 4TB 的堆空间；
  - 方便在此基础上引入新的 GC 特性和利用 colord；
  - 针以及 Load barriers 优化奠定基础；
  - 当前**只支持 Linux/x64 位平台 停顿时间在 10ms 以下**，10ms 其实是一个很保守的数据，即便是 10ms 这个数据，也是 GC 调优几乎达不到的极值。

###### 启用参数

- ```shell
  -XX：+ UnlockExperimentalVMOptions -XX：+ UseZGC -Xmx10g
  ```

- ZGC 是一个并发收集器，**必须要设置一个最大堆的大小**。

